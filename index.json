[{"categories":["开发"],"content":"在Go语言项目中使用Zap日志库","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"本文先介绍了Go语言原生的日志库的使用，然后详细介绍了非常流行的Uber开源的zap日志库，同时介绍了如何搭配Lumberjack实现日志的切割和归档。 在Go语言项目中使用Zap日志库 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:0:0","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"介绍 在许多Go语言项目中，我们需要一个好的日志记录器能够提供下面这些功能： 能够将事件记录到文件中，而不是应用程序控制台。 日志切割-能够根据文件大小、时间或间隔等来切割日志文件。 支持不同的日志级别。例如INFO，DEBUG，ERROR等。 能够打印基本信息，如调用文件/函数名和行号，日志时间等。 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:1:0","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"默认的Go Logger 在介绍Uber-go的zap包之前，让我们先看看Go语言提供的基本日志功能。Go语言提供的默认日志包是https://golang.org/pkg/log/ ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:0","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"实现Go Logger 实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。 设置Logger 我们可以像下面的代码一样设置日志记录器 func SetupLogger() { logFileLocation, _ := os.OpenFile(\"/Users/q1mi/test.log\", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0744) log.SetOutput(logFileLocation) } 使用Logger 让我们来写一些虚拟的代码来使用这个日志记录器。 在当前的示例中，我们将建立一个到URL的HTTP连接，并将状态代码/错误记录到日志文件中。 func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { log.Printf(\"Error fetching url %s : %s\", url, err.Error()) } else { log.Printf(\"Status Code for %s : %s\", url, resp.Status) resp.Body.Close() } } Logger的运行 现在让我们执行上面的代码并查看日志记录器的运行情况。 func main() { SetupLogger() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } 当我们执行上面的代码，我们能看到一个test.log文件被创建，下面的内容会被添加到这个日志文件中。 2019/05/24 01:14:13 Error fetching url www.google.com : Get www.google.com: unsupported protocol scheme \"\" 2019/05/24 01:14:14 Status Code for http://www.google.com : 200 OK ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:1","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"Go Logger的优势和劣势 优势 它最大的优点是使用非常简单。我们可以设置任何io.Writer作为日志记录输出并向其发送要写入的日志。 劣势 仅限基本的日志级别 只有一个Print选项。不支持INFO/DEBUG等多个级别。 对于错误日志，它有Fatal和Panic Fatal日志通过调用os.Exit(1)来结束程序 Panic日志在写入日志消息之后抛出一个panic 但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误 缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。 不提供日志切割的能力。 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:2:2","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"Uber-go Zap Zap是非常快的、结构化的，分日志级别的Go日志库。 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:0","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"为什么选择Uber-go zap 它同时提供了结构化日志记录和printf风格的日志记录 它非常的快 根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息 记录一条消息和10个字段: Package Time Time % to zap Objects Allocated ⚡️ zap 862 ns/op +0% 5 allocs/op ⚡️ zap (sugared) 1250 ns/op +45% 11 allocs/op zerolog 4021 ns/op +366% 76 allocs/op go-kit 4542 ns/op +427% 105 allocs/op apex/log 26785 ns/op +3007% 115 allocs/op logrus 29501 ns/op +3322% 125 allocs/op log15 29906 ns/op +3369% 122 allocs/op 记录一个静态字符串，没有任何上下文或printf风格的模板： Package Time Time % to zap Objects Allocated ⚡️ zap 118 ns/op +0% 0 allocs/op ⚡️ zap (sugared) 191 ns/op +62% 2 allocs/op zerolog 93 ns/op -21% 0 allocs/op go-kit 280 ns/op +137% 11 allocs/op standard library 499 ns/op +323% 2 allocs/op apex/log 1990 ns/op +1586% 10 allocs/op logrus 3129 ns/op +2552% 24 allocs/op log15 3887 ns/op +3194% 23 allocs/op ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:1","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"安装 运行下面的命令安装zap go get -u go.uber.org/zap ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:2","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"配置Zap Logger Zap提供了两种类型的日志记录器—Sugared Logger和Logger。 在性能很好但不是很关键的上下文中，使用SugaredLogger。它比其他结构化日志记录包快4-10倍，并且支持结构化和printf风格的日志记录。 在每一微秒和每一次内存分配都很重要的上下文中，使用Logger。它甚至比SugaredLogger更快，内存分配次数也更少，但它只支持强类型的结构化日志记录。 Logger 通过调用zap.NewProduction()/zap.NewDevelopment()或者zap.Example()创建一个Logger。 上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。 通过Logger调用Info/Error等。 默认情况下日志都会打印到应用程序的console界面。 var logger *zap.Logger func main() { InitLogger() defer logger.Sync() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } func InitLogger() { logger, _ = zap.NewProduction() } func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { logger.Error( \"Error fetching url..\", zap.String(\"url\", url), zap.Error(err)) } else { logger.Info(\"Success..\", zap.String(\"statusCode\", resp.Status), zap.String(\"url\", url)) resp.Body.Close() } } 在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。 日志记录器方法的语法是这样的： func (log *Logger) MethodXXX(msg string, fields ...Field) 其中MethodXXX是一个可变参数函数，可以是Info / Error/ Debug / Panic等。每个方法都接受一个消息字符串和任意数量的zapcore.Field场参数。 每个zapcore.Field其实就是一组键值对参数。 我们执行上面的代码会得到如下输出结果： {\"level\":\"error\",\"ts\":1572159218.912792,\"caller\":\"zap_demo/temp.go:25\",\"msg\":\"Error fetching url..\",\"url\":\"www.sogo.com\",\"error\":\"Get www.sogo.com: unsupported protocol scheme \\\"\\\"\",\"stacktrace\":\"main.simpleHttpGet\\n\\t/Users/q1mi/zap_demo/temp.go:25\\nmain.main\\n\\t/Users/q1mi/zap_demo/temp.go:14\\nruntime.main\\n\\t/usr/local/go/src/runtime/proc.go:203\"} {\"level\":\"info\",\"ts\":1572159219.1227388,\"caller\":\"zap_demo/temp.go:30\",\"msg\":\"Success..\",\"statusCode\":\"200 OK\",\"url\":\"http://www.sogo.com\"} Sugared Logger 现在让我们使用Sugared Logger来实现相同的功能。 大部分的实现基本都相同。 惟一的区别是，我们通过调用主logger的. Sugar()方法来获取一个SugaredLogger。 然后使用SugaredLogger以printf格式记录语句 下面是修改过后使用SugaredLogger代替Logger的代码： var sugarLogger *zap.SugaredLogger func main() { InitLogger() defer sugarLogger.Sync() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } func InitLogger() { logger, _ := zap.NewProduction() sugarLogger = logger.Sugar() } func simpleHttpGet(url string) { sugarLogger.Debugf(\"Trying to hit GET request for %s\", url) resp, err := http.Get(url) if err != nil { sugarLogger.Errorf(\"Error fetching URL %s : Error = %s\", url, err) } else { sugarLogger.Infof(\"Success! statusCode = %s for URL %s\", resp.Status, url) resp.Body.Close() } } 当你执行上面的代码会得到如下输出： {\"level\":\"error\",\"ts\":1572159149.923002,\"caller\":\"logic/temp2.go:27\",\"msg\":\"Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \\\"\\\"\",\"stacktrace\":\"main.simpleHttpGet\\n\\t/Users/q1mi/zap_demo/logic/temp2.go:27\\nmain.main\\n\\t/Users/q1mi/zap_demo/logic/temp2.go:14\\nruntime.main\\n\\t/usr/local/go/src/runtime/proc.go:203\"} {\"level\":\"info\",\"ts\":1572159150.192585,\"caller\":\"logic/temp2.go:29\",\"msg\":\"Success! statusCode = 200 OK for URL http://www.sogo.com\"} 你应该注意到的了，到目前为止这两个logger都打印输出JSON结构格式。 在本博客的后面部分，我们将更详细地讨论SugaredLogger，并了解如何进一步配置它。 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:3","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"定制logger 将日志写入文件而不是终端 我们要做的第一个更改是把日志写入文件，而不是打印到应用程序控制台。 我们将使用zap.New(…)方法来手动传递所有配置，而不是使用像zap.NewProduction()这样的预置方法来创建logger。 func New(core zapcore.Core, options ...Option) *Logger zapcore.Core需要三个配置——Encoder，WriteSyncer，LogLevel。 1.Encoder:编码器(如何写入日志)。我们将使用开箱即用的NewJSONEncoder()，并使用预先设置的ProductionEncoderConfig()。 zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) 2.WriterSyncer ：指定日志将写到哪里去。我们使用zapcore.AddSync()函数并且将打开的文件句柄传进去。 file, _ := os.Create(\"./test.log\") writeSyncer := zapcore.AddSync(file) 3.Log Level：哪种级别的日志将被写入。 我们将修改上述部分中的Logger代码，并重写InitLogger()方法。其余方法—main() /SimpleHttpGet()保持不变。 func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { return zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) } func getLogWriter() zapcore.WriteSyncer { file, _ := os.Create(\"./test.log\") return zapcore.AddSync(file) } 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 {\"level\":\"debug\",\"ts\":1572160754.994731,\"msg\":\"Trying to hit GET request for www.sogo.com\"} {\"level\":\"error\",\"ts\":1572160754.994982,\"msg\":\"Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \\\"\\\"\"} {\"level\":\"debug\",\"ts\":1572160754.994996,\"msg\":\"Trying to hit GET request for http://www.sogo.com\"} {\"level\":\"info\",\"ts\":1572160757.3755069,\"msg\":\"Success! statusCode = 200 OK for URL http://www.sogo.com\"} 将JSON Encoder更改为普通的Log Encoder 现在，我们希望将编码器从JSON Encoder更改为普通Encoder。为此，我们需要将NewJSONEncoder()更改为NewConsoleEncoder()。 return zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 1.572161051846623e+09 debug Trying to hit GET request for www.sogo.com 1.572161051846828e+09 error Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 1.5721610518468401e+09 debug Trying to hit GET request for http://www.sogo.com 1.572161052068744e+09 info Success! statusCode = 200 OK for URL http://www.sogo.com 更改时间编码并添加调用者详细信息 鉴于我们对配置所做的更改，有下面两个问题： 时间是以非人类可读的方式展示，例如1.572161051846623e+09 调用方函数的详细信息没有显示在日志中 我们要做的第一件事是覆盖默认的ProductionConfig()，并进行以下更改: 修改时间编码器 在日志文件中使用大写字母记录日志级别 func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } 接下来，我们将修改zap logger代码，添加将调用函数信息记录到日志中的功能。为此，我们将在zap.New(..)函数中添加一个Option。 logger := zap.New(core, zap.AddCaller()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 2019-10-27T15:33:29.855+0800 DEBUG logic/temp2.go:47 Trying to hit GET request for www.sogo.com 2019-10-27T15:33:29.855+0800 ERROR logic/temp2.go:50 Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 2019-10-27T15:33:29.856+0800 DEBUG logic/temp2.go:47 Trying to hit GET request for http://www.sogo.com 2019-10-27T15:33:30.125+0800 INFO logic/temp2.go:52 Success! statusCode = 200 OK for URL http://www.sogo.com AddCallerSkip 当我们不是直接使用初始化好的logger实例记录日志，而是将其包装成一个函数等，此时日录日志的函数调用链会增加，想要获得准确的调用信息就需要通过AddCallerSkip函数来跳过。 logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1)) 将日志输出到多个位置 我们可以将日志同时输出到文件和终端。 func getLogWriter() zapcore.WriteSyncer { file, _ := os.Create(\"./test.log\") // 利用io.MultiWriter支持文件和终端两个输出目标 ws := io.MultiWriter(file, os.Stdout) return zapcore.AddSync(ws) } 将err日志单独输出到文件 有时候我们除了将全量日志输出到xx.log文件中之外，还希望将ERROR级别的日志单独输出到一个名为xx.err.log的日志文件中。我们可以通过以下方式实现。 func InitLogger() { encoder := getEncoder() // test.log记录全量日志 logF, _ := os.Create(\"./test.log\") c1 := zapcore.NewCore(encoder, zapcore.AddSync(logF), zapcore.DebugLevel) // test.err.log记录ERROR级别的日志 errF, _ := os.Create(\"./test.err.log\") c2 := zapcore.NewCore(encoder, zapcore.AddSync(errF), zap.ErrorLevel) // 使用NewTee将c1和c2合并到core core := zapcore.NewTee(c1, c2) logger = zap.New(core, zap.A","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:3:4","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"使用Lumberjack进行日志切割归档 这个日志程序中唯一缺少的就是日志切割归档功能。 Zap本身不支持切割归档日志文件 官方的说法是为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 目前只支持按文件大小切割，原因是按时间切割效率低且不能保证日志数据不被破坏。详情戳https://github.com/natefinch/lumberjack/issues/54。 想按日期切割可以使用github.com/lestrrat-go/file-rotatelogs这个库，虽然目前不维护了，但也够用了。 // 使用file-rotatelogs按天切割日志 import rotatelogs \"github.com/lestrrat-go/file-rotatelogs\" l, _ := rotatelogs.New( filename+\".%Y%m%d%H%M\", rotatelogs.WithMaxAge(30*24*time.Hour), // 最长保存30天 rotatelogs.WithRotationTime(time.Hour*24), // 24小时切割一次 ) zapcore.AddSync(l) ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:4:0","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"安装 执行下面的命令安装 Lumberjack v2 版本。 go get gopkg.in/natefinch/lumberjack.v2 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:4:1","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"zap logger中加入Lumberjack 要在zap中加入Lumberjack支持，我们需要修改WriteSyncer代码。我们将按照下面的代码修改getLogWriter()函数： func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026lumberjack.Logger{ Filename: \"./test.log\", MaxSize: 10, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } Lumberjack Logger采用以下属性作为输入: Filename: 日志文件的位置 MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位） MaxBackups：保留旧文件的最大个数 MaxAges：保留旧文件的最大天数 Compress：是否压缩/归档旧文件 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:4:2","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"测试所有功能 最终，使用Zap/Lumberjack logger的完整示例代码如下： package main import ( \"net/http\" \"gopkg.in/natefinch/lumberjack.v2\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" ) var sugarLogger *zap.SugaredLogger func main() { InitLogger() defer sugarLogger.Sync() simpleHttpGet(\"www.sogo.com\") simpleHttpGet(\"http://www.sogo.com\") } func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core, zap.AddCaller()) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026lumberjack.Logger{ Filename: \"./test.log\", MaxSize: 1, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } func simpleHttpGet(url string) { sugarLogger.Debugf(\"Trying to hit GET request for %s\", url) resp, err := http.Get(url) if err != nil { sugarLogger.Errorf(\"Error fetching URL %s : Error = %s\", url, err) } else { sugarLogger.Infof(\"Success! statusCode = %s for URL %s\", resp.Status, url) resp.Body.Close() } } 执行上述代码，下面的内容会输出到文件——test.log中。 2019-10-27T15:50:32.944+0800 DEBUG logic/temp2.go:48 Trying to hit GET request for www.sogo.com 2019-10-27T15:50:32.944+0800 ERROR logic/temp2.go:51 Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 2019-10-27T15:50:32.944+0800 DEBUG logic/temp2.go:48 Trying to hit GET request for http://www.sogo.com 2019-10-27T15:50:33.165+0800 INFO logic/temp2.go:53 Success! statusCode = 200 OK for URL http://www.sogo.com 同时，可以在main函数中循环记录日志，测试日志文件是否会自动切割和归档（日志文件每1MB会切割并且在当前目录下最多保存5个备份）。 至此，我们总结了如何将Zap日志程序集成到Go应用程序项目中。 ","date":"2022-10-20","objectID":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/:4:3","tags":["go","日志","第三方库"],"title":"Zap日志库的使用","uri":"/posts/zap%E6%97%A5%E5%BF%97%E5%BA%93/"},{"categories":["开发"],"content":"DO痘痘","date":"2022-10-20","objectID":"/posts/test/","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"本文先介绍了Go语言原生的日志库的使用，然后详细介绍了非常流行的Uber开源的zap日志库，同时介绍了如何搭配Lumberjack实现日志的切割和归档。 在Go语言项目中使用Zap日志库 ","date":"2022-10-20","objectID":"/posts/test/:0:0","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"介绍 在许多Go语言项目中，我们需要一个好的日志记录器能够提供下面这些功能： 能够将事件记录到文件中，而不是应用程序控制台。 日志切割-能够根据文件大小、时间或间隔等来切割日志文件。 支持不同的日志级别。例如INFO，DEBUG，ERROR等。 能够打印基本信息，如调用文件/函数名和行号，日志时间等。 ","date":"2022-10-20","objectID":"/posts/test/:1:0","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"默认的Go Logger 在介绍Uber-go的zap包之前，让我们先看看Go语言提供的基本日志功能。Go语言提供的默认日志包是https://golang.org/pkg/log/ ","date":"2022-10-20","objectID":"/posts/test/:2:0","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"实现Go Logger 实现一个Go语言中的日志记录器非常简单——创建一个新的日志文件，然后设置它为日志的输出位置。 设置Logger 我们可以像下面的代码一样设置日志记录器 func SetupLogger() { logFileLocation, _ := os.OpenFile(\"/Users/q1mi/test.log\", os.O_CREATE|os.O_APPEND|os.O_RDWR, 0744) log.SetOutput(logFileLocation) } 使用Logger 让我们来写一些虚拟的代码来使用这个日志记录器。 在当前的示例中，我们将建立一个到URL的HTTP连接，并将状态代码/错误记录到日志文件中。 func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { log.Printf(\"Error fetching url %s : %s\", url, err.Error()) } else { log.Printf(\"Status Code for %s : %s\", url, resp.Status) resp.Body.Close() } } Logger的运行 现在让我们执行上面的代码并查看日志记录器的运行情况。 func main() { SetupLogger() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } 当我们执行上面的代码，我们能看到一个test.log文件被创建，下面的内容会被添加到这个日志文件中。 2019/05/24 01:14:13 Error fetching url www.google.com : Get www.google.com: unsupported protocol scheme \"\" 2019/05/24 01:14:14 Status Code for http://www.google.com : 200 OK ","date":"2022-10-20","objectID":"/posts/test/:2:1","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"Go Logger的优势和劣势 优势 它最大的优点是使用非常简单。我们可以设置任何io.Writer作为日志记录输出并向其发送要写入的日志。 劣势 仅限基本的日志级别 只有一个Print选项。不支持INFO/DEBUG等多个级别。 对于错误日志，它有Fatal和Panic Fatal日志通过调用os.Exit(1)来结束程序 Panic日志在写入日志消息之后抛出一个panic 但是它缺少一个ERROR日志级别，这个级别可以在不抛出panic或退出程序的情况下记录错误 缺乏日志格式化的能力——例如记录调用者的函数名和行号，格式化日期和时间格式。等等。 不提供日志切割的能力。 ","date":"2022-10-20","objectID":"/posts/test/:2:2","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"Uber-go Zap Zap是非常快的、结构化的，分日志级别的Go日志库。 ","date":"2022-10-20","objectID":"/posts/test/:3:0","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"为什么选择Uber-go zap 它同时提供了结构化日志记录和printf风格的日志记录 它非常的快 根据Uber-go Zap的文档，它的性能比类似的结构化日志包更好——也比标准库更快。 以下是Zap发布的基准测试信息 记录一条消息和10个字段: Package Time Time % to zap Objects Allocated ⚡️ zap 862 ns/op +0% 5 allocs/op ⚡️ zap (sugared) 1250 ns/op +45% 11 allocs/op zerolog 4021 ns/op +366% 76 allocs/op go-kit 4542 ns/op +427% 105 allocs/op apex/log 26785 ns/op +3007% 115 allocs/op logrus 29501 ns/op +3322% 125 allocs/op log15 29906 ns/op +3369% 122 allocs/op 记录一个静态字符串，没有任何上下文或printf风格的模板： Package Time Time % to zap Objects Allocated ⚡️ zap 118 ns/op +0% 0 allocs/op ⚡️ zap (sugared) 191 ns/op +62% 2 allocs/op zerolog 93 ns/op -21% 0 allocs/op go-kit 280 ns/op +137% 11 allocs/op standard library 499 ns/op +323% 2 allocs/op apex/log 1990 ns/op +1586% 10 allocs/op logrus 3129 ns/op +2552% 24 allocs/op log15 3887 ns/op +3194% 23 allocs/op ","date":"2022-10-20","objectID":"/posts/test/:3:1","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"安装 运行下面的命令安装zap go get -u go.uber.org/zap ","date":"2022-10-20","objectID":"/posts/test/:3:2","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"配置Zap Logger Zap提供了两种类型的日志记录器—Sugared Logger和Logger。 在性能很好但不是很关键的上下文中，使用SugaredLogger。它比其他结构化日志记录包快4-10倍，并且支持结构化和printf风格的日志记录。 在每一微秒和每一次内存分配都很重要的上下文中，使用Logger。它甚至比SugaredLogger更快，内存分配次数也更少，但它只支持强类型的结构化日志记录。 Logger 通过调用zap.NewProduction()/zap.NewDevelopment()或者zap.Example()创建一个Logger。 上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。 通过Logger调用Info/Error等。 默认情况下日志都会打印到应用程序的console界面。 var logger *zap.Logger func main() { InitLogger() defer logger.Sync() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } func InitLogger() { logger, _ = zap.NewProduction() } func simpleHttpGet(url string) { resp, err := http.Get(url) if err != nil { logger.Error( \"Error fetching url..\", zap.String(\"url\", url), zap.Error(err)) } else { logger.Info(\"Success..\", zap.String(\"statusCode\", resp.Status), zap.String(\"url\", url)) resp.Body.Close() } } 在上面的代码中，我们首先创建了一个Logger，然后使用Info/ Error等Logger方法记录消息。 日志记录器方法的语法是这样的： func (log *Logger) MethodXXX(msg string, fields ...Field) 其中MethodXXX是一个可变参数函数，可以是Info / Error/ Debug / Panic等。每个方法都接受一个消息字符串和任意数量的zapcore.Field场参数。 每个zapcore.Field其实就是一组键值对参数。 我们执行上面的代码会得到如下输出结果： {\"level\":\"error\",\"ts\":1572159218.912792,\"caller\":\"zap_demo/temp.go:25\",\"msg\":\"Error fetching url..\",\"url\":\"www.sogo.com\",\"error\":\"Get www.sogo.com: unsupported protocol scheme \\\"\\\"\",\"stacktrace\":\"main.simpleHttpGet\\n\\t/Users/q1mi/zap_demo/temp.go:25\\nmain.main\\n\\t/Users/q1mi/zap_demo/temp.go:14\\nruntime.main\\n\\t/usr/local/go/src/runtime/proc.go:203\"} {\"level\":\"info\",\"ts\":1572159219.1227388,\"caller\":\"zap_demo/temp.go:30\",\"msg\":\"Success..\",\"statusCode\":\"200 OK\",\"url\":\"http://www.sogo.com\"} Sugared Logger 现在让我们使用Sugared Logger来实现相同的功能。 大部分的实现基本都相同。 惟一的区别是，我们通过调用主logger的. Sugar()方法来获取一个SugaredLogger。 然后使用SugaredLogger以printf格式记录语句 下面是修改过后使用SugaredLogger代替Logger的代码： var sugarLogger *zap.SugaredLogger func main() { InitLogger() defer sugarLogger.Sync() simpleHttpGet(\"www.google.com\") simpleHttpGet(\"http://www.google.com\") } func InitLogger() { logger, _ := zap.NewProduction() sugarLogger = logger.Sugar() } func simpleHttpGet(url string) { sugarLogger.Debugf(\"Trying to hit GET request for %s\", url) resp, err := http.Get(url) if err != nil { sugarLogger.Errorf(\"Error fetching URL %s : Error = %s\", url, err) } else { sugarLogger.Infof(\"Success! statusCode = %s for URL %s\", resp.Status, url) resp.Body.Close() } } 当你执行上面的代码会得到如下输出： {\"level\":\"error\",\"ts\":1572159149.923002,\"caller\":\"logic/temp2.go:27\",\"msg\":\"Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \\\"\\\"\",\"stacktrace\":\"main.simpleHttpGet\\n\\t/Users/q1mi/zap_demo/logic/temp2.go:27\\nmain.main\\n\\t/Users/q1mi/zap_demo/logic/temp2.go:14\\nruntime.main\\n\\t/usr/local/go/src/runtime/proc.go:203\"} {\"level\":\"info\",\"ts\":1572159150.192585,\"caller\":\"logic/temp2.go:29\",\"msg\":\"Success! statusCode = 200 OK for URL http://www.sogo.com\"} 你应该注意到的了，到目前为止这两个logger都打印输出JSON结构格式。 在本博客的后面部分，我们将更详细地讨论SugaredLogger，并了解如何进一步配置它。 ","date":"2022-10-20","objectID":"/posts/test/:3:3","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"定制logger 将日志写入文件而不是终端 我们要做的第一个更改是把日志写入文件，而不是打印到应用程序控制台。 我们将使用zap.New(…)方法来手动传递所有配置，而不是使用像zap.NewProduction()这样的预置方法来创建logger。 func New(core zapcore.Core, options ...Option) *Logger zapcore.Core需要三个配置——Encoder，WriteSyncer，LogLevel。 1.Encoder:编码器(如何写入日志)。我们将使用开箱即用的NewJSONEncoder()，并使用预先设置的ProductionEncoderConfig()。 zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) 2.WriterSyncer ：指定日志将写到哪里去。我们使用zapcore.AddSync()函数并且将打开的文件句柄传进去。 file, _ := os.Create(\"./test.log\") writeSyncer := zapcore.AddSync(file) 3.Log Level：哪种级别的日志将被写入。 我们将修改上述部分中的Logger代码，并重写InitLogger()方法。其余方法—main() /SimpleHttpGet()保持不变。 func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { return zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) } func getLogWriter() zapcore.WriteSyncer { file, _ := os.Create(\"./test.log\") return zapcore.AddSync(file) } 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 {\"level\":\"debug\",\"ts\":1572160754.994731,\"msg\":\"Trying to hit GET request for www.sogo.com\"} {\"level\":\"error\",\"ts\":1572160754.994982,\"msg\":\"Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \\\"\\\"\"} {\"level\":\"debug\",\"ts\":1572160754.994996,\"msg\":\"Trying to hit GET request for http://www.sogo.com\"} {\"level\":\"info\",\"ts\":1572160757.3755069,\"msg\":\"Success! statusCode = 200 OK for URL http://www.sogo.com\"} 将JSON Encoder更改为普通的Log Encoder 现在，我们希望将编码器从JSON Encoder更改为普通Encoder。为此，我们需要将NewJSONEncoder()更改为NewConsoleEncoder()。 return zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 1.572161051846623e+09 debug Trying to hit GET request for www.sogo.com 1.572161051846828e+09 error Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 1.5721610518468401e+09 debug Trying to hit GET request for http://www.sogo.com 1.572161052068744e+09 info Success! statusCode = 200 OK for URL http://www.sogo.com 更改时间编码并添加调用者详细信息 鉴于我们对配置所做的更改，有下面两个问题： 时间是以非人类可读的方式展示，例如1.572161051846623e+09 调用方函数的详细信息没有显示在日志中 我们要做的第一件事是覆盖默认的ProductionConfig()，并进行以下更改: 修改时间编码器 在日志文件中使用大写字母记录日志级别 func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } 接下来，我们将修改zap logger代码，添加将调用函数信息记录到日志中的功能。为此，我们将在zap.New(..)函数中添加一个Option。 logger := zap.New(core, zap.AddCaller()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。 2019-10-27T15:33:29.855+0800 DEBUG logic/temp2.go:47 Trying to hit GET request for www.sogo.com 2019-10-27T15:33:29.855+0800 ERROR logic/temp2.go:50 Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 2019-10-27T15:33:29.856+0800 DEBUG logic/temp2.go:47 Trying to hit GET request for http://www.sogo.com 2019-10-27T15:33:30.125+0800 INFO logic/temp2.go:52 Success! statusCode = 200 OK for URL http://www.sogo.com AddCallerSkip 当我们不是直接使用初始化好的logger实例记录日志，而是将其包装成一个函数等，此时日录日志的函数调用链会增加，想要获得准确的调用信息就需要通过AddCallerSkip函数来跳过。 logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1)) 将日志输出到多个位置 我们可以将日志同时输出到文件和终端。 func getLogWriter() zapcore.WriteSyncer { file, _ := os.Create(\"./test.log\") // 利用io.MultiWriter支持文件和终端两个输出目标 ws := io.MultiWriter(file, os.Stdout) return zapcore.AddSync(ws) } 将err日志单独输出到文件 有时候我们除了将全量日志输出到xx.log文件中之外，还希望将ERROR级别的日志单独输出到一个名为xx.err.log的日志文件中。我们可以通过以下方式实现。 func InitLogger() { encoder := getEncoder() // test.log记录全量日志 logF, _ := os.Create(\"./test.log\") c1 := zapcore.NewCore(encoder, zapcore.AddSync(logF), zapcore.DebugLevel) // test.err.log记录ERROR级别的日志 errF, _ := os.Create(\"./test.err.log\") c2 := zapcore.NewCore(encoder, zapcore.AddSync(errF), zap.ErrorLevel) // 使用NewTee将c1和c2合并到core core := zapcore.NewTee(c1, c2) logger = zap.New(core, zap.A","date":"2022-10-20","objectID":"/posts/test/:3:4","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"使用Lumberjack进行日志切割归档 这个日志程序中唯一缺少的就是日志切割归档功能。 Zap本身不支持切割归档日志文件 官方的说法是为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。 目前只支持按文件大小切割，原因是按时间切割效率低且不能保证日志数据不被破坏。详情戳https://github.com/natefinch/lumberjack/issues/54。 想按日期切割可以使用github.com/lestrrat-go/file-rotatelogs这个库，虽然目前不维护了，但也够用了。 // 使用file-rotatelogs按天切割日志 import rotatelogs \"github.com/lestrrat-go/file-rotatelogs\" l, _ := rotatelogs.New( filename+\".%Y%m%d%H%M\", rotatelogs.WithMaxAge(30*24*time.Hour), // 最长保存30天 rotatelogs.WithRotationTime(time.Hour*24), // 24小时切割一次 ) zapcore.AddSync(l) ","date":"2022-10-20","objectID":"/posts/test/:4:0","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"安装 执行下面的命令安装 Lumberjack v2 版本。 go get gopkg.in/natefinch/lumberjack.v2 ","date":"2022-10-20","objectID":"/posts/test/:4:1","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"zap logger中加入Lumberjack 要在zap中加入Lumberjack支持，我们需要修改WriteSyncer代码。我们将按照下面的代码修改getLogWriter()函数： func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026lumberjack.Logger{ Filename: \"./test.log\", MaxSize: 10, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } Lumberjack Logger采用以下属性作为输入: Filename: 日志文件的位置 MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位） MaxBackups：保留旧文件的最大个数 MaxAges：保留旧文件的最大天数 Compress：是否压缩/归档旧文件 ","date":"2022-10-20","objectID":"/posts/test/:4:2","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["开发"],"content":"测试所有功能 最终，使用Zap/Lumberjack logger的完整示例代码如下： package main import ( \"net/http\" \"gopkg.in/natefinch/lumberjack.v2\" \"go.uber.org/zap\" \"go.uber.org/zap/zapcore\" ) var sugarLogger *zap.SugaredLogger func main() { InitLogger() defer sugarLogger.Sync() simpleHttpGet(\"www.sogo.com\") simpleHttpGet(\"http://www.sogo.com\") } func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core, zap.AddCaller()) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026lumberjack.Logger{ Filename: \"./test.log\", MaxSize: 1, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } func simpleHttpGet(url string) { sugarLogger.Debugf(\"Trying to hit GET request for %s\", url) resp, err := http.Get(url) if err != nil { sugarLogger.Errorf(\"Error fetching URL %s : Error = %s\", url, err) } else { sugarLogger.Infof(\"Success! statusCode = %s for URL %s\", resp.Status, url) resp.Body.Close() } } 执行上述代码，下面的内容会输出到文件——test.log中。 2019-10-27T15:50:32.944+0800 DEBUG logic/temp2.go:48 Trying to hit GET request for www.sogo.com 2019-10-27T15:50:32.944+0800 ERROR logic/temp2.go:51 Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \"\" 2019-10-27T15:50:32.944+0800 DEBUG logic/temp2.go:48 Trying to hit GET request for http://www.sogo.com 2019-10-27T15:50:33.165+0800 INFO logic/temp2.go:53 Success! statusCode = 200 OK for URL http://www.sogo.com 同时，可以在main函数中循环记录日志，测试日志文件是否会自动切割和归档（日志文件每1MB会切割并且在当前目录下最多保存5个备份）。 至此，我们总结了如何将Zap日志程序集成到Go应用程序项目中。 ","date":"2022-10-20","objectID":"/posts/test/:4:3","tags":["go","日志","第三方库"],"title":"测试1234","uri":"/posts/test/"},{"categories":["运维"],"content":"Node Export 基于用户名密码访问","date":"2022-10-20","objectID":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/","tags":["监控","prometheus","exporter"],"title":"为NodeExport配置访问密码","uri":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"Export采集指标的地址谁都可以访问，这里可以通过添加基础认证的方式，使用用户名密码认证的方式去采集被监控端，提高安全性 ","date":"2022-10-20","objectID":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/:0:0","tags":["监控","prometheus","exporter"],"title":"为NodeExport配置访问密码","uri":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"配置被监控端 这个配置文件里面是要访问我暴露的指标需要的用户名密码。用户名和密码，密码是采用了一定的加密方式的，而不是写明文 生成密码 [root@localhost ~]# yum install httpd-tools –y 下面就是输入123456之后加密的密码，将这个密码保存在配置文件当中 [root@localhost ~]# htpasswd -nBC 12 '' | tr -d ':\\\\\\\\n' New password: Re-type new password: $2y$12$y4PaNc0UM0Jzi07jJf6zcuRFyp2GlH6F5rUKcE.xk3Aug2khcqa7m 修改其配置文件 [root@localhost node_exporter]# vim config.yml [root@localhost node_exporter]# cat config.yml basic_auth_users: prometheus: $2y$12$y4PaNc0UM0Jzi07jJf6zcuRFyp2GlH6F5rUKcE.xk3Aug2khcqa7m 现在让export引用这个配置文件 [root@localhost node_exporter]# vim /usr/lib/systemd/system/node_exporter.service ExecStart=/usr/local/node_exporter/node_exporter --web.config=/usr/local/node_exporter/config.yml [root@localhost node_exporter]# systemctl daemon-reload [root@localhost node_exporter]# systemctl restart node_exporter 输入prometheus加上密码123456 同时现在普罗米修斯没有配置，可以看到采集不了数据了 ","date":"2022-10-20","objectID":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/:1:0","tags":["监控","prometheus","exporter"],"title":"为NodeExport配置访问密码","uri":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"配置普罗米修斯 启用用户名密码访问 [root@localhost prometheus]# vim /usr/local/prometheus/prometheus.yml - job_name: 'webserver' basic_auth: username: prometheus password: 123456 static_configs: - targets: ['192.168.179.99:9100','192.168.179.102:9100'] [root@localhost prometheus]# ./promtool check config prometheus.yml Checking prometheus.yml SUCCESS: 0 rule files found 可以看到数据可以正常采集了 ","date":"2022-10-20","objectID":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/:2:0","tags":["监控","prometheus","exporter"],"title":"为NodeExport配置访问密码","uri":"/posts/node-export-%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"firewalld防火墙配置","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"服务配置 启动： systemctl start firewalld.service 查看状态： systemctl status firewalld.service 停止： systemctl disable firewalld.service 禁用： systemctl stop firewalld.service ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:1","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"三种策略 ACCEPT 允许 REJECT 拒绝 DROP 丢弃 ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:2","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"1. 查看 # 查看激活的域 firewall-cmd --get-active-zones # 查看开放的端口 firewall-cmd --zone=public --list-ports # 查看开放的服务 firewall-cmd --zone=public --list-services # 查看添加的规则 firewall-cmd --zone=public --list-rich-rules ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:3","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"2. 添加端口 ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:4","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"常用命令 #开放单个端口 firewall-cmd --zone=public --add-port=80/tcp --permanent # 开放端口范围 firewall-cmd --zone=public --add-port=8388-8389/tcp --permanent # 对 147.152.139.197 开放10000端口 firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"147.152.139.197/32\" port protocol=\"tcp\" port=\"10000\" accept\" # 拒绝端口： firewall-cmd --permanent --zone=public --add-rich-rule=' rule family=\"ipv4\" source address=\"47.52.39.197/32\" port protocol=\"tcp\" port=\"10000\" reject' # 开放全部端口给IP firewall-cmd --permanent --zone=public --add-rich-rule=' rule family=\"ipv4\" source address=\"192.168.0.1/32\" accept' # 开放全部端口给网段 firewall-cmd --permanent --zone=public --add-rich-rule=' rule family=\"ipv4\" source address=\"192.168.0.0/16\" accept' ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:5","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"3. 添加服务 # 查看全部支持的服务 firewall-cmd --get-service # 查看开放的服务 firewall-cmd --list-service # 添加服务,添加https firewall-cmd --add-service=https --permanent # 修改对应的配置文件是/etc/firewalld/zones/public.xml ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:6","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"4. 移除端口 # 移除添加的端口(其它的增加的策略也是将add改为remove即可) firewall-cmd --zone=public --remove-port=80/tcp --permanent ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:7","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"5. 重载配置 # 对路由规则进行修改后，需要重新加载规则才能使规则生效 firewall-cmd --reload ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:8","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"实战应用 ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:9","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"(1)限制ssh访问，仅允许白名单IP登录 也可以通过在/etc/host.deny里面配置来实现 # 取消默认开启的没有访问限制的ssh服务，让ssh服务默认情况下拒绝连接 firewall-cmd --permanent --remove-service=ssh # 允许特定ip或ip段访问22端口的ssh服务 firewall-cmd --permanent --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.0/24\" port protocol=\"tcp\" port=\"22\" accept' # 重载firewall配置，使其生效 firewall-cmd --reload ","date":"2022-10-20","objectID":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/:0:10","tags":["centos","防火墙"],"title":"防火墙配置","uri":"/posts/%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"},{"categories":["开发"],"content":"go pretty库","date":"2022-10-19","objectID":"/posts/go-pretty/","tags":["go","第三方库"],"title":"Go Pretty","uri":"/posts/go-pretty/"},{"categories":["开发"],"content":"用于美化表格，列表，进度条，文本等的控制台输出 jedib0t/go-pretty: Table-writer and more in golang! (github.com) ","date":"2022-10-19","objectID":"/posts/go-pretty/:0:0","tags":["go","第三方库"],"title":"Go Pretty","uri":"/posts/go-pretty/"},{"categories":["开发"],"content":"table 可以在输出美化的表格 package main import ( \"os\" \"github.com/jedib0t/go-pretty/v6/table\" ) type Student struct { ID int Name string Age int School string } var students = []Student{ {ID: 1, Name: \"张三\", Age: 18, School: \"清华大学\"}, {ID: 2, Name: \"李四\", Age: 19, School: \"北京大学\"}, {ID: 3, Name: \"王五\", Age: 20, School: \"复旦大学\"}, {ID: 4, Name: \"赵六\", Age: 21, School: \"上海交通大学\"}, } func (s Student) toRow() table.Row { return table.Row{s.ID, s.Name, s.Age, s.School} } func main() { t := table.NewWriter() t.SetOutputMirror(os.Stdout) t.AppendHeader(table.Row{\"ID\", \"姓名\", \"年龄\", \"学校\"}) for _, s := range students { t.AppendRow(s.toRow()) } t.SetStyle(table.StyleColoredDark) t.Render() } 运行可以在终端中得到 Render同时也支持渲染html、csv等… ","date":"2022-10-19","objectID":"/posts/go-pretty/:1:0","tags":["go","第三方库"],"title":"Go Pretty","uri":"/posts/go-pretty/"}]